# Smart Event Reservation & Anomaly Monitoring System

> 트래픽 급증 환경에서 동시성 문제를 해결하는 **이벤트 예약 시스템**과, 로그 기반 이상 탐지를 통해 사전 장애 대응이 가능한 **모니터링 시스템**입니다.

<br/>

## 1. 프로젝트 목적 (The "Why")

이 프로젝트는 단순 CRUD 구현을 넘어, **대규모 서비스 환경을 가정한 아키텍처 설계 및 문제 해결 능력**을 보여주는 것을 목표로 합니다. 이벤트 오픈 시 발생하는 전형적인 문제점들을 다음과 같은 기술적 접근으로 해결했습니다.

### 문제 정의
* **순간적인 트래픽 급증:** DB Lock 경합으로 인한 응답 지연 발생
* **데이터 정합성 위협:** 동일 좌석에 대한 다수의 동시 예약 요청
* **장애 대응 지연:** 수동 로그 확인으로 인한 사후 처리 한계

### 해결 목표
* 동시성 제어 전략 비교 및 최적의 솔루션 적용
* 캐싱 전략을 통한 읽기 성능 개선 및 DB 부하 분산
* 메시지 큐(Kafka)를 활용한 이벤트 기반 로그 수집 구조 설계
* 머신러닝(AI) 기반 실시간 이상 탐지 시스템 도입

<br/>

## 2. 시스템 아키텍처 (System Architecture)

```text
[Frontend] React + TypeScript
   └── [Web Server] Nginx
        └── [Backend API] Spring Boot (Java 17)
             ├── [Database/Cache] MySQL / Redis
             └── [Message Broker] Kafka
                  └── [AI Server] Python + FastAPI

```

## 3. 기술 선택 이유 (Tech Stack & Decision)

| 분류 | 기술 스택 | 선택 이유 |
| :--- | :--- | :--- |
| **Backend** | `Java 17`, `Spring Boot` | LTS 기반의 안정성 확보, 대규모 서비스에서 검증된 프레임워크, Spring 생태계(JPA, Security 등)의 적극적인 활용 가능 |
| **Cache & Lock** | `Redis` | 이벤트 목록 조회 시 캐싱을 통한 DB 부하 감소, 분산 락(Distributed Lock) 구현을 통한 동시성 문제 해결 |
| **Message Broker**| `Kafka` | 비동기 이벤트 기반으로 로그 수집 처리, AI 서버와의 느슨한 결합(Loose Coupling) 구조 유지 |
| **Frontend** | `React`, `TypeScript` | 컴포넌트 기반 구조로 유지보수성 향상, 타입 안정성 확보를 통한 런타임 오류 감소, 대규모 서비스 친화적 아키텍처 |
| **AI / ML** | `Python`, `FastAPI`, `Isolation Forest` | 초기 구현 난이도 대비 효과적인 이상 탐지, 모델 교체가 용이한 확장성 확보 |

<br/>

## 4. 도메인 설계 (Domain Design)

비즈니스 로직을 엔티티 내부에서 처리하도록 하여 **객체지향적인 응집도**를 높이는 데 집중했습니다.

* **주요 엔티티:** `User`, `Event`, `Seat`, `Reservation`, `Payment`, `Log`, `AnomalyResult`
* **상태 기반 설계:** `Reservation`은 상태(`PENDING` → `CONFIRMED` → `CANCELED`)를 기반으로 관리됩니다.
* **정합성 유지:** * `Payment` 성공 시에만 `Reservation` 상태가 `CONFIRMED`로 전이됩니다.
  * `Seat`는 `Event`에 종속되도록 설계하여 데이터 정합성을 보장합니다.

<br/>

## 5 .동시성 처리 전략 (Concurrency Control)

**[문제 상황]** 동일 좌석에 대해 동시 예약 요청이 발생할 경우, 중복 예약 또는 데이터 불일치 가능성이 존재했습니다. 이를 해결하기 위해 두 가지 전략을 비교 및 적용했습니다.

### 🔹 1차 전략: 낙관적 락 (Optimistic Lock)
* **방식:** `Version` 필드를 사용하고, 충돌 발생 시 애플리케이션 단에서 재시도 로직을 구현했습니다.
* **결과:** DB 락을 최소화하여 구현이 비교적 간단하나, 티켓팅과 같이 충돌 빈도가 높은 환경에서는 잦은 재시도로 인한 성능 저하가 발생했습니다.

### 🔹 2차 전략: Redis 분산 락 (Distributed Lock) 🏆 *(최종 도입)*
* **방식:** `Redisson` 라이브러리를 기반으로 `seatId` 단위로 락을 적용했습니다.
* **결과:** 동시 요청 500건 테스트 환경에서 **데이터 정합성을 완벽히 유지(중복 예약 0건)**했으며, 응답 속도 또한 안정화되었습니다.

<br/>

## 6. 캐싱 전략 (Caching Strategy)

읽기 요청이 집중되는 이벤트 목록 조회 구간의 병목을 해결하기 위해 캐싱을 도입했습니다.

* 이벤트 목록 조회 API에 **Redis 캐시** 적용
* TTL(Time-to-Live) 설정을 통한 자동 만료 처리
* 이벤트 정보 수정 시 **캐시 무효화(Cache Invalidation)** 전략 적용하여 구형 데이터 노출 방지
* **성과:** DB 부하를 **약 40% 감소**시키는 데 성공했습니다.

<br/>

## 7. AI 이상 탐지 시스템 (AI Anomaly Detection)



* **로그 흐름:** `Spring Boot` → `Kafka` → `AI Server` → `분석 결과 DB 저장` → `Slack 알림`
* **모델 구조:** `Isolation Forest` 모델을 기반으로 CPU 사용률, 응답 시간, 트래픽 로그를 분석합니다. 이상 점수(Threshold) 기준을 초과하면 즉시 알림을 발생시킵니다.
* **확장 전략:** AI 서버를 독립적인 마이크로서비스로 분리하여, 향후 백엔드 서버의 수정 없이 AI 모델만 유연하게 교체할 수 있도록 설계했습니다.

<br/>

## 8. 성능 테스트 (Performance Testing)

`JMeter`를 활용하여 동시 접속자 100명 / 300명 / 500명 환경에서 부하 테스트를 수행하여 성능 개선을 검증했습니다.

* 🚀 **응답 시간 개선:** Redis 캐시 적용 후 평균 응답 시간 **2.1s → 380ms** 로 대폭 개선
* 🛡️ **정합성 검증:** 분산 락 적용 후 500건 동시 예약 요청 테스트에서 **중복 예약 0건** 달성

<br/>

## 9. CI/CD 및 배포 (CI/CD & Deployment)

* **CI/CD:** `GitHub Actions`를 활용한 빌드 및 테스트 자동화
* **Containerization:** `Docker`를 활용한 이미지 빌드
* **Server:** `AWS EC2` 클라우드 환경에 서비스 배포
* **Proxy:** `Nginx` 리버스 프록시 적용으로 웹 서버 최적화 및 보안 강화

<br/>

## 10. 트러블 슈팅 (Troubleshooting)

| 문제 상황 | 원인 | 해결 방안 |
| :--- | :--- | :--- |
| **N+1 문제 발생** | JPA의 지연 로딩(Lazy Loading)으로 인해 연관된 엔티티를 조회할 때 불필요한 추가 쿼리가 다수 발생 | **Fetch Join**을 적용하여 연관된 데이터를 한 번의 쿼리로 가져오도록 최적화 |
| **Redis TTL 설정 오류** | 잘못된 캐시 만료 정책으로 인해 데이터 수정 후에도 변경 사항이 반영되지 않음 | 이벤트 수정 비즈니스 로직 내에 명시적인 **캐시 무효화(Evict) 로직** 추가 |

<br/>

## 11. 향후 개선 방향 (Future Work)

- [ ] 트래픽 폭증을 제어하기 위한 대기열(Queue) 시스템 도입
- [ ] 모놀리식 구조에서 MSA(Microservices Architecture) 구조로의 전환 실험
- [ ] 읽기와 쓰기 책임을 분리하는 CQRS 패턴 적용
- [ ] 시계열 예측에 특화된 LSTM 기반 이상 탐지 모델로의 고도화

---

## 이 README의 목적

이 프로젝트는 단순한 CRUD 기반의 구현을 넘어, 아래의 목표들을 통해 **대규모 서비스 환경을 가정한 백엔드 시스템 설계 능력**을 보여주는 것을 핵심으로 합니다.

1. 동시성 제어 전략 비교 및 적용
2. 캐싱 전략 설계 및 읽기 성능 개선
3. 메시지 브로커를 활용한 이벤트 기반 아키텍처 도입
4. AI 기반 이상 탐지 시스템 적용 구조 설계
